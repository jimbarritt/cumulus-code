Object Calisthenics Notes

#1: Use only one level of indentation per method

Moved a lot of loops into their own methods.

Tricky were the try/catches - in this case, there are 0 levels if indent inside the try/catch.  These are almost like a lopp-removal but tend to be more woven into the rest of the method.  This particular refoactor smelled a little bad to me.

Also tricky: one instance of a "collect" pattern - before:

 @Override public String toString() {	
      String ret = this.getClass().getSimpleName() + "<";	
      boolean first = true;
      for( int k : denominations.keySet() ) {
          if( ! first ) {	
              ret += ",";	
          } else {	
              first = false;	
          }	
          ret += k;	
          ret += "'s:";	
          ret += denominations.get( k );	
      }	
      return ret + ">";	
      items.add( item );
  }

I tried to get tricky and introduce a first-class "foreach" in order to use an already-introduced stringJoin.  After:

 @Override public String toString() {
      final Collection<Object> items = new ArrayList<Object>();
      new Foreach( denominations.keySet() ) {
          public @Override void each( Object o ) {
              denominationToString(o, items);
          }
      }.apply();
      return this.getClass().getSimpleName() + "<" + Helpers.stringJoin( items, "," ) + ">";
  }

This looks bad.  The boilerplate is uglt.  Actually what I ended up liking better was this:

 @Override public String toString() {
      final Collection<Object> items = new ArrayList<Object>();
      for( int item : denominations.keySet() ) {
          items.add( denominationToString( o, items ) );
      }
      return this.getClass().getSimpleName() + "<" + Helpers.stringJoin( items, "," ) + ">";
  }

But on further reflection on the pursuit of first-class functions, maybe what I *really* wanted might have been this:

@Override public String toString() {
     final Collection<Object> items = 
	     new Collect( denominations.keySet() ) {
	         public @Override void each( Object o ) {
	             denominationToString(o, items);
	         }
	     }.apply();
     return this.getClass().getSimpleName() + "<" + Helpers.stringJoin( items, "," ) + ">";
 }

The boilerplate kills the elegance.  If there were more going on besides the boilerplate, I'd like this pattern.  On the other hand, if you consider this:
new Collect( denominations.keySet() ) {
    public @Override void each( Object o ) {
...
}.apply() ... should be reduced to simply:

collect { }

- you see where I'm coming from.


