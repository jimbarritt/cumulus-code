Object Calisthenics Notes

#1: Use only one level of indentation per method

Moved a lot of loops into their own methods.

I noticed a pattern I used to find min, and also stringJoin.  Old:

public static String stringJoin( Collection<?> objects, String joiner ) {
    StringBuilder builder = new StringBuilder();
    boolean first = true;
    for( Object o : objects ) {
        if( ! first ) {
            builder.append( joiner );
        } else {
            first = false;
        }
        builder.append( (null == o) ? "null" : o.toString() );
    }
    return builder.toString();
}

new:

public static String stringJoin( Collection<?> objects, String joiner ) {
    StringBuilder builder = new StringBuilder();
    boolean first = true;
    for( Object o : objects ) {
        first = stringJoinAppend( o, joiner, builder, first );
    }
    return builder.toString();
}

private static boolean stringJoinAppend( Object o, String joiner, StringBuilder builder, boolean first ) {
    if( ! first ) {
        builder.append( joiner );
    } else {
        first = false;
    }
    builder.append( (null == o) ? "null" : o.toString() );        
    return first;
}

The key point is - There is a state variable (in the case, first - in the case of findMin, min).  Ths variable is modified by the helper and reassigned in the body.  The impl of findMin seemed more "tricky" to me:

BEFORE:
private CoinSet findMinimalCoinCountSolution(Collection<CoinSet> coinSets) {
     CoinSet theLeast = null;
     for( CoinSet coinSet : coinSets ) {
	     if( null == theLeast || coinSet.getNumCoins() < theLeast.getNumCoins() ) {
	         theLeast = coinSet;
	     }
     }
     return theLeast;
 }

AFTER:

private CoinSet findMinimalCoinCountSolution(Collection<CoinSet> coinSets) {
     CoinSet theLeast = null;
     for( CoinSet coinSet : coinSets ) {
         theLeast = isItLess( theLeast, coinSet );
     }
     return theLeast;
 }

 private CoinSet isItLess(CoinSet theLeast, CoinSet coinSet) {
     if( null == theLeast || coinSet.getNumCoins() < theLeast.getNumCoins() ) {
         theLeast = coinSet;
     }
     return theLeast;
 }

Tricky were the try/catches - in this case, there are 0 levels if indent inside the try/catch.  These are almost like a lopp-removal but tend to be more woven into the rest of the method.  This particular refoactor smelled a little bad to me.

Also tricky: one instance of a "collect" pattern - before:

 @Override public String toString() {	
      String ret = this.getClass().getSimpleName() + "<";	
      boolean first = true;
      for( int k : denominations.keySet() ) {
          if( ! first ) {	
              ret += ",";	
          } else {	
              first = false;	
          }	
          ret += k;	
          ret += "'s:";	
          ret += denominations.get( k );	
      }	
      return ret + ">";	
      items.add( item );
  }

I tried to get tricky and introduce a first-class "foreach" in order to use an already-introduced stringJoin.  After:

 @Override public String toString() {
      final Collection<Object> items = new ArrayList<Object>();
      new Foreach( denominations.keySet() ) {
          public @Override void each( Object o ) {
              denominationToString(o, items);
          }
      }.apply();
      return this.getClass().getSimpleName() + "<" + Helpers.stringJoin( items, "," ) + ">";
  }

This looks bad.  The boilerplate is ugly.  Actually what I ended up liking better was this:

 @Override public String toString() {
      final Collection<Object> items = new ArrayList<Object>();
      for( int item : denominations.keySet() ) {
          items.add( denominationToString( o, items ) );
      }
      return this.getClass().getSimpleName() + "<" + Helpers.stringJoin( items, "," ) + ">";
  }

But on further reflection on the pursuit of first-class functions, maybe what I *really* wanted might have been this:

@Override public String toString() {
     final Collection<Object> items = 
	     new Collect( denominations.keySet() ) {
	         public @Override void each( Object o ) {
	             denominationToString(o, items);
	         }
	     }.apply();
     return this.getClass().getSimpleName() + "<" + Helpers.stringJoin( items, "," ) + ">";
 }

The boilerplate kills the elegance.  If there were more going on besides the boilerplate, I'd like this pattern.  On the other hand, if you consider this:
new Collect( denominations.keySet() ) {
    public @Override void each( Object o ) {
...
}.apply() ... should be reduced to simply:

collect { }

- you see where I'm coming from.


#2: Do not use the "else" keyword.

Well, fortunately I had only 5:

./src/com/thoughtworks/cschuyle/CoinSet.java:        } else {
./src/com/thoughtworks/cschuyle/CompleteSolution.java:        } else if( coinSet.sum() != total ) {
./src/com/thoughtworks/cschuyle/MinNumCoinsSolver.java:                else if solve x-den
./src/com/thoughtworks/cschuyle/MinNumCoinsSolver.java:        } else if( denomination < total ) {
./src/com/thoughtworks/cschuyle/util/Helpers.java:        } else {



